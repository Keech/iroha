// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: event.proto

#ifndef PROTOBUF_event_2eproto__INCLUDED
#define PROTOBUF_event_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace Event {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_event_2eproto();
void protobuf_AssignDesc_event_2eproto();
void protobuf_ShutdownFile_event_2eproto();

class Account;
class Asset;
class ConsensusEvent;
class Domain;
class EventSignature;
class Object;
class Peer;
class SimpleAsset;
class StatusResponse;
class Transaction;
class Trust;
class TxSignatures;

// ===================================================================

class Object : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Event.Object) */ {
 public:
  Object();
  virtual ~Object();

  Object(const Object& from);

  inline Object& operator=(const Object& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Object& default_instance();

  void Swap(Object* other);

  // implements Message ----------------------------------------------

  inline Object* New() const { return New(NULL); }

  Object* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Object& from);
  void MergeFrom(const Object& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Object* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string valueStr = 1;
  void clear_valuestr();
  static const int kValueStrFieldNumber = 1;
  const ::std::string& valuestr() const;
  void set_valuestr(const ::std::string& value);
  void set_valuestr(const char* value);
  void set_valuestr(const char* value, size_t size);
  ::std::string* mutable_valuestr();
  ::std::string* release_valuestr();
  void set_allocated_valuestr(::std::string* valuestr);

  // optional int64 valueInt = 2;
  void clear_valueint();
  static const int kValueIntFieldNumber = 2;
  ::google::protobuf::int64 valueint() const;
  void set_valueint(::google::protobuf::int64 value);

  // optional bool valueBool = 3;
  void clear_valuebool();
  static const int kValueBoolFieldNumber = 3;
  bool valuebool() const;
  void set_valuebool(bool value);

  // optional double valueDouble = 4;
  void clear_valuedouble();
  static const int kValueDoubleFieldNumber = 4;
  double valuedouble() const;
  void set_valuedouble(double value);

  // optional string name = 5;
  void clear_name();
  static const int kNameFieldNumber = 5;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Event.Object)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr valuestr_;
  ::google::protobuf::int64 valueint_;
  double valuedouble_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  bool valuebool_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_event_2eproto();
  friend void protobuf_AssignDesc_event_2eproto();
  friend void protobuf_ShutdownFile_event_2eproto();

  void InitAsDefaultInstance();
  static Object* default_instance_;
};
// -------------------------------------------------------------------

class SimpleAsset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Event.SimpleAsset) */ {
 public:
  SimpleAsset();
  virtual ~SimpleAsset();

  SimpleAsset(const SimpleAsset& from);

  inline SimpleAsset& operator=(const SimpleAsset& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SimpleAsset& default_instance();

  void Swap(SimpleAsset* other);

  // implements Message ----------------------------------------------

  inline SimpleAsset* New() const { return New(NULL); }

  SimpleAsset* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SimpleAsset& from);
  void MergeFrom(const SimpleAsset& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SimpleAsset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string domain = 1;
  void clear_domain();
  static const int kDomainFieldNumber = 1;
  const ::std::string& domain() const;
  void set_domain(const ::std::string& value);
  void set_domain(const char* value);
  void set_domain(const char* value, size_t size);
  ::std::string* mutable_domain();
  ::std::string* release_domain();
  void set_allocated_domain(::std::string* domain);

  // optional string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .Event.Object value = 3;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::Event::Object& value() const;
  ::Event::Object* mutable_value();
  ::Event::Object* release_value();
  void set_allocated_value(::Event::Object* value);

  // @@protoc_insertion_point(class_scope:Event.SimpleAsset)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr domain_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::Event::Object* value_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_event_2eproto();
  friend void protobuf_AssignDesc_event_2eproto();
  friend void protobuf_ShutdownFile_event_2eproto();

  void InitAsDefaultInstance();
  static SimpleAsset* default_instance_;
};
// -------------------------------------------------------------------

class Asset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Event.Asset) */ {
 public:
  Asset();
  virtual ~Asset();

  Asset(const Asset& from);

  inline Asset& operator=(const Asset& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Asset& default_instance();

  void Swap(Asset* other);

  // implements Message ----------------------------------------------

  inline Asset* New() const { return New(NULL); }

  Asset* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Asset& from);
  void MergeFrom(const Asset& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Asset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string domain = 1;
  void clear_domain();
  static const int kDomainFieldNumber = 1;
  const ::std::string& domain() const;
  void set_domain(const ::std::string& value);
  void set_domain(const char* value);
  void set_domain(const char* value, size_t size);
  ::std::string* mutable_domain();
  ::std::string* release_domain();
  void set_allocated_domain(::std::string* domain);

  // optional string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated .Event.Object map = 3;
  int map_size() const;
  void clear_map();
  static const int kMapFieldNumber = 3;
  const ::Event::Object& map(int index) const;
  ::Event::Object* mutable_map(int index);
  ::Event::Object* add_map();
  ::google::protobuf::RepeatedPtrField< ::Event::Object >*
      mutable_map();
  const ::google::protobuf::RepeatedPtrField< ::Event::Object >&
      map() const;

  // @@protoc_insertion_point(class_scope:Event.Asset)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr domain_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedPtrField< ::Event::Object > map_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_event_2eproto();
  friend void protobuf_AssignDesc_event_2eproto();
  friend void protobuf_ShutdownFile_event_2eproto();

  void InitAsDefaultInstance();
  static Asset* default_instance_;
};
// -------------------------------------------------------------------

class Domain : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Event.Domain) */ {
 public:
  Domain();
  virtual ~Domain();

  Domain(const Domain& from);

  inline Domain& operator=(const Domain& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Domain& default_instance();

  void Swap(Domain* other);

  // implements Message ----------------------------------------------

  inline Domain* New() const { return New(NULL); }

  Domain* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Domain& from);
  void MergeFrom(const Domain& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Domain* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ownerPublicKey = 1;
  void clear_ownerpublickey();
  static const int kOwnerPublicKeyFieldNumber = 1;
  const ::std::string& ownerpublickey() const;
  void set_ownerpublickey(const ::std::string& value);
  void set_ownerpublickey(const char* value);
  void set_ownerpublickey(const char* value, size_t size);
  ::std::string* mutable_ownerpublickey();
  ::std::string* release_ownerpublickey();
  void set_allocated_ownerpublickey(::std::string* ownerpublickey);

  // optional string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Event.Domain)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr ownerpublickey_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_event_2eproto();
  friend void protobuf_AssignDesc_event_2eproto();
  friend void protobuf_ShutdownFile_event_2eproto();

  void InitAsDefaultInstance();
  static Domain* default_instance_;
};
// -------------------------------------------------------------------

class Account : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Event.Account) */ {
 public:
  Account();
  virtual ~Account();

  Account(const Account& from);

  inline Account& operator=(const Account& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Account& default_instance();

  void Swap(Account* other);

  // implements Message ----------------------------------------------

  inline Account* New() const { return New(NULL); }

  Account* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Account& from);
  void MergeFrom(const Account& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Account* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string publicKey = 1;
  void clear_publickey();
  static const int kPublicKeyFieldNumber = 1;
  const ::std::string& publickey() const;
  void set_publickey(const ::std::string& value);
  void set_publickey(const char* value);
  void set_publickey(const char* value, size_t size);
  ::std::string* mutable_publickey();
  ::std::string* release_publickey();
  void set_allocated_publickey(::std::string* publickey);

  // optional string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated .Event.Asset assets = 3;
  int assets_size() const;
  void clear_assets();
  static const int kAssetsFieldNumber = 3;
  const ::Event::Asset& assets(int index) const;
  ::Event::Asset* mutable_assets(int index);
  ::Event::Asset* add_assets();
  ::google::protobuf::RepeatedPtrField< ::Event::Asset >*
      mutable_assets();
  const ::google::protobuf::RepeatedPtrField< ::Event::Asset >&
      assets() const;

  // @@protoc_insertion_point(class_scope:Event.Account)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr publickey_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedPtrField< ::Event::Asset > assets_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_event_2eproto();
  friend void protobuf_AssignDesc_event_2eproto();
  friend void protobuf_ShutdownFile_event_2eproto();

  void InitAsDefaultInstance();
  static Account* default_instance_;
};
// -------------------------------------------------------------------

class Trust : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Event.Trust) */ {
 public:
  Trust();
  virtual ~Trust();

  Trust(const Trust& from);

  inline Trust& operator=(const Trust& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Trust& default_instance();

  void Swap(Trust* other);

  // implements Message ----------------------------------------------

  inline Trust* New() const { return New(NULL); }

  Trust* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Trust& from);
  void MergeFrom(const Trust& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Trust* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  double value() const;
  void set_value(double value);

  // optional bool isOk = 2;
  void clear_isok();
  static const int kIsOkFieldNumber = 2;
  bool isok() const;
  void set_isok(bool value);

  // @@protoc_insertion_point(class_scope:Event.Trust)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  double value_;
  bool isok_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_event_2eproto();
  friend void protobuf_AssignDesc_event_2eproto();
  friend void protobuf_ShutdownFile_event_2eproto();

  void InitAsDefaultInstance();
  static Trust* default_instance_;
};
// -------------------------------------------------------------------

class Peer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Event.Peer) */ {
 public:
  Peer();
  virtual ~Peer();

  Peer(const Peer& from);

  inline Peer& operator=(const Peer& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Peer& default_instance();

  void Swap(Peer* other);

  // implements Message ----------------------------------------------

  inline Peer* New() const { return New(NULL); }

  Peer* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Peer& from);
  void MergeFrom(const Peer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Peer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string publicKey = 1;
  void clear_publickey();
  static const int kPublicKeyFieldNumber = 1;
  const ::std::string& publickey() const;
  void set_publickey(const ::std::string& value);
  void set_publickey(const char* value);
  void set_publickey(const char* value, size_t size);
  ::std::string* mutable_publickey();
  ::std::string* release_publickey();
  void set_allocated_publickey(::std::string* publickey);

  // optional string address = 2;
  void clear_address();
  static const int kAddressFieldNumber = 2;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // optional .Event.Trust trust = 3;
  bool has_trust() const;
  void clear_trust();
  static const int kTrustFieldNumber = 3;
  const ::Event::Trust& trust() const;
  ::Event::Trust* mutable_trust();
  ::Event::Trust* release_trust();
  void set_allocated_trust(::Event::Trust* trust);

  // @@protoc_insertion_point(class_scope:Event.Peer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr publickey_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::Event::Trust* trust_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_event_2eproto();
  friend void protobuf_AssignDesc_event_2eproto();
  friend void protobuf_ShutdownFile_event_2eproto();

  void InitAsDefaultInstance();
  static Peer* default_instance_;
};
// -------------------------------------------------------------------

class TxSignatures : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Event.TxSignatures) */ {
 public:
  TxSignatures();
  virtual ~TxSignatures();

  TxSignatures(const TxSignatures& from);

  inline TxSignatures& operator=(const TxSignatures& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxSignatures& default_instance();

  void Swap(TxSignatures* other);

  // implements Message ----------------------------------------------

  inline TxSignatures* New() const { return New(NULL); }

  TxSignatures* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxSignatures& from);
  void MergeFrom(const TxSignatures& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TxSignatures* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string publicKey = 1;
  void clear_publickey();
  static const int kPublicKeyFieldNumber = 1;
  const ::std::string& publickey() const;
  void set_publickey(const ::std::string& value);
  void set_publickey(const char* value);
  void set_publickey(const char* value, size_t size);
  ::std::string* mutable_publickey();
  ::std::string* release_publickey();
  void set_allocated_publickey(::std::string* publickey);

  // optional string signature = 2;
  void clear_signature();
  static const int kSignatureFieldNumber = 2;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  void set_signature(const char* value);
  void set_signature(const char* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:Event.TxSignatures)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr publickey_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_event_2eproto();
  friend void protobuf_AssignDesc_event_2eproto();
  friend void protobuf_ShutdownFile_event_2eproto();

  void InitAsDefaultInstance();
  static TxSignatures* default_instance_;
};
// -------------------------------------------------------------------

class EventSignature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Event.EventSignature) */ {
 public:
  EventSignature();
  virtual ~EventSignature();

  EventSignature(const EventSignature& from);

  inline EventSignature& operator=(const EventSignature& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EventSignature& default_instance();

  void Swap(EventSignature* other);

  // implements Message ----------------------------------------------

  inline EventSignature* New() const { return New(NULL); }

  EventSignature* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EventSignature& from);
  void MergeFrom(const EventSignature& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EventSignature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string publicKey = 1;
  void clear_publickey();
  static const int kPublicKeyFieldNumber = 1;
  const ::std::string& publickey() const;
  void set_publickey(const ::std::string& value);
  void set_publickey(const char* value);
  void set_publickey(const char* value, size_t size);
  ::std::string* mutable_publickey();
  ::std::string* release_publickey();
  void set_allocated_publickey(::std::string* publickey);

  // optional string signature = 2;
  void clear_signature();
  static const int kSignatureFieldNumber = 2;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  void set_signature(const char* value);
  void set_signature(const char* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:Event.EventSignature)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr publickey_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_event_2eproto();
  friend void protobuf_AssignDesc_event_2eproto();
  friend void protobuf_ShutdownFile_event_2eproto();

  void InitAsDefaultInstance();
  static EventSignature* default_instance_;
};
// -------------------------------------------------------------------

class Transaction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Event.Transaction) */ {
 public:
  Transaction();
  virtual ~Transaction();

  Transaction(const Transaction& from);

  inline Transaction& operator=(const Transaction& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Transaction& default_instance();

  void Swap(Transaction* other);

  // implements Message ----------------------------------------------

  inline Transaction* New() const { return New(NULL); }

  Transaction* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Transaction& from);
  void MergeFrom(const Transaction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Transaction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Event.TxSignatures txSignatures = 1;
  int txsignatures_size() const;
  void clear_txsignatures();
  static const int kTxSignaturesFieldNumber = 1;
  const ::Event::TxSignatures& txsignatures(int index) const;
  ::Event::TxSignatures* mutable_txsignatures(int index);
  ::Event::TxSignatures* add_txsignatures();
  ::google::protobuf::RepeatedPtrField< ::Event::TxSignatures >*
      mutable_txsignatures();
  const ::google::protobuf::RepeatedPtrField< ::Event::TxSignatures >&
      txsignatures() const;

  // optional string type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional string senderPubkey = 3;
  void clear_senderpubkey();
  static const int kSenderPubkeyFieldNumber = 3;
  const ::std::string& senderpubkey() const;
  void set_senderpubkey(const ::std::string& value);
  void set_senderpubkey(const char* value);
  void set_senderpubkey(const char* value, size_t size);
  ::std::string* mutable_senderpubkey();
  ::std::string* release_senderpubkey();
  void set_allocated_senderpubkey(::std::string* senderpubkey);

  // optional string hash = 4;
  void clear_hash();
  static const int kHashFieldNumber = 4;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // optional uint64 timestamp = 5;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // optional .Event.Asset asset = 6;
  bool has_asset() const;
  void clear_asset();
  static const int kAssetFieldNumber = 6;
  const ::Event::Asset& asset() const;
  ::Event::Asset* mutable_asset();
  ::Event::Asset* release_asset();
  void set_allocated_asset(::Event::Asset* asset);

  // optional .Event.SimpleAsset simpleAsset = 7;
  bool has_simpleasset() const;
  void clear_simpleasset();
  static const int kSimpleAssetFieldNumber = 7;
  const ::Event::SimpleAsset& simpleasset() const;
  ::Event::SimpleAsset* mutable_simpleasset();
  ::Event::SimpleAsset* release_simpleasset();
  void set_allocated_simpleasset(::Event::SimpleAsset* simpleasset);

  // optional .Event.Domain domain = 8;
  bool has_domain() const;
  void clear_domain();
  static const int kDomainFieldNumber = 8;
  const ::Event::Domain& domain() const;
  ::Event::Domain* mutable_domain();
  ::Event::Domain* release_domain();
  void set_allocated_domain(::Event::Domain* domain);

  // optional .Event.Account account = 9;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 9;
  const ::Event::Account& account() const;
  ::Event::Account* mutable_account();
  ::Event::Account* release_account();
  void set_allocated_account(::Event::Account* account);

  // optional .Event.Peer peer = 10;
  bool has_peer() const;
  void clear_peer();
  static const int kPeerFieldNumber = 10;
  const ::Event::Peer& peer() const;
  ::Event::Peer* mutable_peer();
  ::Event::Peer* release_peer();
  void set_allocated_peer(::Event::Peer* peer);

  // optional string receivePubkey = 11;
  void clear_receivepubkey();
  static const int kReceivePubkeyFieldNumber = 11;
  const ::std::string& receivepubkey() const;
  void set_receivepubkey(const ::std::string& value);
  void set_receivepubkey(const char* value);
  void set_receivepubkey(const char* value, size_t size);
  ::std::string* mutable_receivepubkey();
  ::std::string* release_receivepubkey();
  void set_allocated_receivepubkey(::std::string* receivepubkey);

  // @@protoc_insertion_point(class_scope:Event.Transaction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::Event::TxSignatures > txsignatures_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr senderpubkey_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::uint64 timestamp_;
  ::Event::Asset* asset_;
  ::Event::SimpleAsset* simpleasset_;
  ::Event::Domain* domain_;
  ::Event::Account* account_;
  ::Event::Peer* peer_;
  ::google::protobuf::internal::ArenaStringPtr receivepubkey_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_event_2eproto();
  friend void protobuf_AssignDesc_event_2eproto();
  friend void protobuf_ShutdownFile_event_2eproto();

  void InitAsDefaultInstance();
  static Transaction* default_instance_;
};
// -------------------------------------------------------------------

class ConsensusEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Event.ConsensusEvent) */ {
 public:
  ConsensusEvent();
  virtual ~ConsensusEvent();

  ConsensusEvent(const ConsensusEvent& from);

  inline ConsensusEvent& operator=(const ConsensusEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConsensusEvent& default_instance();

  void Swap(ConsensusEvent* other);

  // implements Message ----------------------------------------------

  inline ConsensusEvent* New() const { return New(NULL); }

  ConsensusEvent* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConsensusEvent& from);
  void MergeFrom(const ConsensusEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConsensusEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Event.EventSignature eventSignatures = 1;
  int eventsignatures_size() const;
  void clear_eventsignatures();
  static const int kEventSignaturesFieldNumber = 1;
  const ::Event::EventSignature& eventsignatures(int index) const;
  ::Event::EventSignature* mutable_eventsignatures(int index);
  ::Event::EventSignature* add_eventsignatures();
  ::google::protobuf::RepeatedPtrField< ::Event::EventSignature >*
      mutable_eventsignatures();
  const ::google::protobuf::RepeatedPtrField< ::Event::EventSignature >&
      eventsignatures() const;

  // optional .Event.Transaction transaction = 2;
  bool has_transaction() const;
  void clear_transaction();
  static const int kTransactionFieldNumber = 2;
  const ::Event::Transaction& transaction() const;
  ::Event::Transaction* mutable_transaction();
  ::Event::Transaction* release_transaction();
  void set_allocated_transaction(::Event::Transaction* transaction);

  // optional uint64 order = 3;
  void clear_order();
  static const int kOrderFieldNumber = 3;
  ::google::protobuf::uint64 order() const;
  void set_order(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Event.ConsensusEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::Event::EventSignature > eventsignatures_;
  ::Event::Transaction* transaction_;
  ::google::protobuf::uint64 order_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_event_2eproto();
  friend void protobuf_AssignDesc_event_2eproto();
  friend void protobuf_ShutdownFile_event_2eproto();

  void InitAsDefaultInstance();
  static ConsensusEvent* default_instance_;
};
// -------------------------------------------------------------------

class StatusResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Event.StatusResponse) */ {
 public:
  StatusResponse();
  virtual ~StatusResponse();

  StatusResponse(const StatusResponse& from);

  inline StatusResponse& operator=(const StatusResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusResponse& default_instance();

  void Swap(StatusResponse* other);

  // implements Message ----------------------------------------------

  inline StatusResponse* New() const { return New(NULL); }

  StatusResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatusResponse& from);
  void MergeFrom(const StatusResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StatusResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:Event.StatusResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_event_2eproto();
  friend void protobuf_AssignDesc_event_2eproto();
  friend void protobuf_ShutdownFile_event_2eproto();

  void InitAsDefaultInstance();
  static StatusResponse* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Object

// optional string valueStr = 1;
inline void Object::clear_valuestr() {
  valuestr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Object::valuestr() const {
  // @@protoc_insertion_point(field_get:Event.Object.valueStr)
  return valuestr_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Object::set_valuestr(const ::std::string& value) {
  
  valuestr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.Object.valueStr)
}
inline void Object::set_valuestr(const char* value) {
  
  valuestr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.Object.valueStr)
}
inline void Object::set_valuestr(const char* value, size_t size) {
  
  valuestr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.Object.valueStr)
}
inline ::std::string* Object::mutable_valuestr() {
  
  // @@protoc_insertion_point(field_mutable:Event.Object.valueStr)
  return valuestr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Object::release_valuestr() {
  // @@protoc_insertion_point(field_release:Event.Object.valueStr)
  
  return valuestr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Object::set_allocated_valuestr(::std::string* valuestr) {
  if (valuestr != NULL) {
    
  } else {
    
  }
  valuestr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), valuestr);
  // @@protoc_insertion_point(field_set_allocated:Event.Object.valueStr)
}

// optional int64 valueInt = 2;
inline void Object::clear_valueint() {
  valueint_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Object::valueint() const {
  // @@protoc_insertion_point(field_get:Event.Object.valueInt)
  return valueint_;
}
inline void Object::set_valueint(::google::protobuf::int64 value) {
  
  valueint_ = value;
  // @@protoc_insertion_point(field_set:Event.Object.valueInt)
}

// optional bool valueBool = 3;
inline void Object::clear_valuebool() {
  valuebool_ = false;
}
inline bool Object::valuebool() const {
  // @@protoc_insertion_point(field_get:Event.Object.valueBool)
  return valuebool_;
}
inline void Object::set_valuebool(bool value) {
  
  valuebool_ = value;
  // @@protoc_insertion_point(field_set:Event.Object.valueBool)
}

// optional double valueDouble = 4;
inline void Object::clear_valuedouble() {
  valuedouble_ = 0;
}
inline double Object::valuedouble() const {
  // @@protoc_insertion_point(field_get:Event.Object.valueDouble)
  return valuedouble_;
}
inline void Object::set_valuedouble(double value) {
  
  valuedouble_ = value;
  // @@protoc_insertion_point(field_set:Event.Object.valueDouble)
}

// optional string name = 5;
inline void Object::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Object::name() const {
  // @@protoc_insertion_point(field_get:Event.Object.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Object::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.Object.name)
}
inline void Object::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.Object.name)
}
inline void Object::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.Object.name)
}
inline ::std::string* Object::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Event.Object.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Object::release_name() {
  // @@protoc_insertion_point(field_release:Event.Object.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Object::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Event.Object.name)
}

// -------------------------------------------------------------------

// SimpleAsset

// optional string domain = 1;
inline void SimpleAsset::clear_domain() {
  domain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SimpleAsset::domain() const {
  // @@protoc_insertion_point(field_get:Event.SimpleAsset.domain)
  return domain_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SimpleAsset::set_domain(const ::std::string& value) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.SimpleAsset.domain)
}
inline void SimpleAsset::set_domain(const char* value) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.SimpleAsset.domain)
}
inline void SimpleAsset::set_domain(const char* value, size_t size) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.SimpleAsset.domain)
}
inline ::std::string* SimpleAsset::mutable_domain() {
  
  // @@protoc_insertion_point(field_mutable:Event.SimpleAsset.domain)
  return domain_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SimpleAsset::release_domain() {
  // @@protoc_insertion_point(field_release:Event.SimpleAsset.domain)
  
  return domain_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SimpleAsset::set_allocated_domain(::std::string* domain) {
  if (domain != NULL) {
    
  } else {
    
  }
  domain_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), domain);
  // @@protoc_insertion_point(field_set_allocated:Event.SimpleAsset.domain)
}

// optional string name = 2;
inline void SimpleAsset::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SimpleAsset::name() const {
  // @@protoc_insertion_point(field_get:Event.SimpleAsset.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SimpleAsset::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.SimpleAsset.name)
}
inline void SimpleAsset::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.SimpleAsset.name)
}
inline void SimpleAsset::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.SimpleAsset.name)
}
inline ::std::string* SimpleAsset::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Event.SimpleAsset.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SimpleAsset::release_name() {
  // @@protoc_insertion_point(field_release:Event.SimpleAsset.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SimpleAsset::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Event.SimpleAsset.name)
}

// optional .Event.Object value = 3;
inline bool SimpleAsset::has_value() const {
  return !_is_default_instance_ && value_ != NULL;
}
inline void SimpleAsset::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) delete value_;
  value_ = NULL;
}
inline const ::Event::Object& SimpleAsset::value() const {
  // @@protoc_insertion_point(field_get:Event.SimpleAsset.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::Event::Object* SimpleAsset::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::Event::Object;
  }
  // @@protoc_insertion_point(field_mutable:Event.SimpleAsset.value)
  return value_;
}
inline ::Event::Object* SimpleAsset::release_value() {
  // @@protoc_insertion_point(field_release:Event.SimpleAsset.value)
  
  ::Event::Object* temp = value_;
  value_ = NULL;
  return temp;
}
inline void SimpleAsset::set_allocated_value(::Event::Object* value) {
  delete value_;
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Event.SimpleAsset.value)
}

// -------------------------------------------------------------------

// Asset

// optional string domain = 1;
inline void Asset::clear_domain() {
  domain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Asset::domain() const {
  // @@protoc_insertion_point(field_get:Event.Asset.domain)
  return domain_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Asset::set_domain(const ::std::string& value) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.Asset.domain)
}
inline void Asset::set_domain(const char* value) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.Asset.domain)
}
inline void Asset::set_domain(const char* value, size_t size) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.Asset.domain)
}
inline ::std::string* Asset::mutable_domain() {
  
  // @@protoc_insertion_point(field_mutable:Event.Asset.domain)
  return domain_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Asset::release_domain() {
  // @@protoc_insertion_point(field_release:Event.Asset.domain)
  
  return domain_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Asset::set_allocated_domain(::std::string* domain) {
  if (domain != NULL) {
    
  } else {
    
  }
  domain_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), domain);
  // @@protoc_insertion_point(field_set_allocated:Event.Asset.domain)
}

// optional string name = 2;
inline void Asset::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Asset::name() const {
  // @@protoc_insertion_point(field_get:Event.Asset.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Asset::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.Asset.name)
}
inline void Asset::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.Asset.name)
}
inline void Asset::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.Asset.name)
}
inline ::std::string* Asset::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Event.Asset.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Asset::release_name() {
  // @@protoc_insertion_point(field_release:Event.Asset.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Asset::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Event.Asset.name)
}

// repeated .Event.Object map = 3;
inline int Asset::map_size() const {
  return map_.size();
}
inline void Asset::clear_map() {
  map_.Clear();
}
inline const ::Event::Object& Asset::map(int index) const {
  // @@protoc_insertion_point(field_get:Event.Asset.map)
  return map_.Get(index);
}
inline ::Event::Object* Asset::mutable_map(int index) {
  // @@protoc_insertion_point(field_mutable:Event.Asset.map)
  return map_.Mutable(index);
}
inline ::Event::Object* Asset::add_map() {
  // @@protoc_insertion_point(field_add:Event.Asset.map)
  return map_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Event::Object >*
Asset::mutable_map() {
  // @@protoc_insertion_point(field_mutable_list:Event.Asset.map)
  return &map_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Event::Object >&
Asset::map() const {
  // @@protoc_insertion_point(field_list:Event.Asset.map)
  return map_;
}

// -------------------------------------------------------------------

// Domain

// optional string ownerPublicKey = 1;
inline void Domain::clear_ownerpublickey() {
  ownerpublickey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Domain::ownerpublickey() const {
  // @@protoc_insertion_point(field_get:Event.Domain.ownerPublicKey)
  return ownerpublickey_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Domain::set_ownerpublickey(const ::std::string& value) {
  
  ownerpublickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.Domain.ownerPublicKey)
}
inline void Domain::set_ownerpublickey(const char* value) {
  
  ownerpublickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.Domain.ownerPublicKey)
}
inline void Domain::set_ownerpublickey(const char* value, size_t size) {
  
  ownerpublickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.Domain.ownerPublicKey)
}
inline ::std::string* Domain::mutable_ownerpublickey() {
  
  // @@protoc_insertion_point(field_mutable:Event.Domain.ownerPublicKey)
  return ownerpublickey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Domain::release_ownerpublickey() {
  // @@protoc_insertion_point(field_release:Event.Domain.ownerPublicKey)
  
  return ownerpublickey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Domain::set_allocated_ownerpublickey(::std::string* ownerpublickey) {
  if (ownerpublickey != NULL) {
    
  } else {
    
  }
  ownerpublickey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ownerpublickey);
  // @@protoc_insertion_point(field_set_allocated:Event.Domain.ownerPublicKey)
}

// optional string name = 2;
inline void Domain::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Domain::name() const {
  // @@protoc_insertion_point(field_get:Event.Domain.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Domain::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.Domain.name)
}
inline void Domain::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.Domain.name)
}
inline void Domain::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.Domain.name)
}
inline ::std::string* Domain::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Event.Domain.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Domain::release_name() {
  // @@protoc_insertion_point(field_release:Event.Domain.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Domain::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Event.Domain.name)
}

// -------------------------------------------------------------------

// Account

// optional string publicKey = 1;
inline void Account::clear_publickey() {
  publickey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Account::publickey() const {
  // @@protoc_insertion_point(field_get:Event.Account.publicKey)
  return publickey_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Account::set_publickey(const ::std::string& value) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.Account.publicKey)
}
inline void Account::set_publickey(const char* value) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.Account.publicKey)
}
inline void Account::set_publickey(const char* value, size_t size) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.Account.publicKey)
}
inline ::std::string* Account::mutable_publickey() {
  
  // @@protoc_insertion_point(field_mutable:Event.Account.publicKey)
  return publickey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Account::release_publickey() {
  // @@protoc_insertion_point(field_release:Event.Account.publicKey)
  
  return publickey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Account::set_allocated_publickey(::std::string* publickey) {
  if (publickey != NULL) {
    
  } else {
    
  }
  publickey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), publickey);
  // @@protoc_insertion_point(field_set_allocated:Event.Account.publicKey)
}

// optional string name = 2;
inline void Account::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Account::name() const {
  // @@protoc_insertion_point(field_get:Event.Account.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Account::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.Account.name)
}
inline void Account::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.Account.name)
}
inline void Account::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.Account.name)
}
inline ::std::string* Account::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Event.Account.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Account::release_name() {
  // @@protoc_insertion_point(field_release:Event.Account.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Account::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Event.Account.name)
}

// repeated .Event.Asset assets = 3;
inline int Account::assets_size() const {
  return assets_.size();
}
inline void Account::clear_assets() {
  assets_.Clear();
}
inline const ::Event::Asset& Account::assets(int index) const {
  // @@protoc_insertion_point(field_get:Event.Account.assets)
  return assets_.Get(index);
}
inline ::Event::Asset* Account::mutable_assets(int index) {
  // @@protoc_insertion_point(field_mutable:Event.Account.assets)
  return assets_.Mutable(index);
}
inline ::Event::Asset* Account::add_assets() {
  // @@protoc_insertion_point(field_add:Event.Account.assets)
  return assets_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Event::Asset >*
Account::mutable_assets() {
  // @@protoc_insertion_point(field_mutable_list:Event.Account.assets)
  return &assets_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Event::Asset >&
Account::assets() const {
  // @@protoc_insertion_point(field_list:Event.Account.assets)
  return assets_;
}

// -------------------------------------------------------------------

// Trust

// optional double value = 1;
inline void Trust::clear_value() {
  value_ = 0;
}
inline double Trust::value() const {
  // @@protoc_insertion_point(field_get:Event.Trust.value)
  return value_;
}
inline void Trust::set_value(double value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:Event.Trust.value)
}

// optional bool isOk = 2;
inline void Trust::clear_isok() {
  isok_ = false;
}
inline bool Trust::isok() const {
  // @@protoc_insertion_point(field_get:Event.Trust.isOk)
  return isok_;
}
inline void Trust::set_isok(bool value) {
  
  isok_ = value;
  // @@protoc_insertion_point(field_set:Event.Trust.isOk)
}

// -------------------------------------------------------------------

// Peer

// optional string publicKey = 1;
inline void Peer::clear_publickey() {
  publickey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Peer::publickey() const {
  // @@protoc_insertion_point(field_get:Event.Peer.publicKey)
  return publickey_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Peer::set_publickey(const ::std::string& value) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.Peer.publicKey)
}
inline void Peer::set_publickey(const char* value) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.Peer.publicKey)
}
inline void Peer::set_publickey(const char* value, size_t size) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.Peer.publicKey)
}
inline ::std::string* Peer::mutable_publickey() {
  
  // @@protoc_insertion_point(field_mutable:Event.Peer.publicKey)
  return publickey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Peer::release_publickey() {
  // @@protoc_insertion_point(field_release:Event.Peer.publicKey)
  
  return publickey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Peer::set_allocated_publickey(::std::string* publickey) {
  if (publickey != NULL) {
    
  } else {
    
  }
  publickey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), publickey);
  // @@protoc_insertion_point(field_set_allocated:Event.Peer.publicKey)
}

// optional string address = 2;
inline void Peer::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Peer::address() const {
  // @@protoc_insertion_point(field_get:Event.Peer.address)
  return address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Peer::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.Peer.address)
}
inline void Peer::set_address(const char* value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.Peer.address)
}
inline void Peer::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.Peer.address)
}
inline ::std::string* Peer::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:Event.Peer.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Peer::release_address() {
  // @@protoc_insertion_point(field_release:Event.Peer.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Peer::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:Event.Peer.address)
}

// optional .Event.Trust trust = 3;
inline bool Peer::has_trust() const {
  return !_is_default_instance_ && trust_ != NULL;
}
inline void Peer::clear_trust() {
  if (GetArenaNoVirtual() == NULL && trust_ != NULL) delete trust_;
  trust_ = NULL;
}
inline const ::Event::Trust& Peer::trust() const {
  // @@protoc_insertion_point(field_get:Event.Peer.trust)
  return trust_ != NULL ? *trust_ : *default_instance_->trust_;
}
inline ::Event::Trust* Peer::mutable_trust() {
  
  if (trust_ == NULL) {
    trust_ = new ::Event::Trust;
  }
  // @@protoc_insertion_point(field_mutable:Event.Peer.trust)
  return trust_;
}
inline ::Event::Trust* Peer::release_trust() {
  // @@protoc_insertion_point(field_release:Event.Peer.trust)
  
  ::Event::Trust* temp = trust_;
  trust_ = NULL;
  return temp;
}
inline void Peer::set_allocated_trust(::Event::Trust* trust) {
  delete trust_;
  trust_ = trust;
  if (trust) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Event.Peer.trust)
}

// -------------------------------------------------------------------

// TxSignatures

// optional string publicKey = 1;
inline void TxSignatures::clear_publickey() {
  publickey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TxSignatures::publickey() const {
  // @@protoc_insertion_point(field_get:Event.TxSignatures.publicKey)
  return publickey_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxSignatures::set_publickey(const ::std::string& value) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.TxSignatures.publicKey)
}
inline void TxSignatures::set_publickey(const char* value) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.TxSignatures.publicKey)
}
inline void TxSignatures::set_publickey(const char* value, size_t size) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.TxSignatures.publicKey)
}
inline ::std::string* TxSignatures::mutable_publickey() {
  
  // @@protoc_insertion_point(field_mutable:Event.TxSignatures.publicKey)
  return publickey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxSignatures::release_publickey() {
  // @@protoc_insertion_point(field_release:Event.TxSignatures.publicKey)
  
  return publickey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxSignatures::set_allocated_publickey(::std::string* publickey) {
  if (publickey != NULL) {
    
  } else {
    
  }
  publickey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), publickey);
  // @@protoc_insertion_point(field_set_allocated:Event.TxSignatures.publicKey)
}

// optional string signature = 2;
inline void TxSignatures::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TxSignatures::signature() const {
  // @@protoc_insertion_point(field_get:Event.TxSignatures.signature)
  return signature_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxSignatures::set_signature(const ::std::string& value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.TxSignatures.signature)
}
inline void TxSignatures::set_signature(const char* value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.TxSignatures.signature)
}
inline void TxSignatures::set_signature(const char* value, size_t size) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.TxSignatures.signature)
}
inline ::std::string* TxSignatures::mutable_signature() {
  
  // @@protoc_insertion_point(field_mutable:Event.TxSignatures.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxSignatures::release_signature() {
  // @@protoc_insertion_point(field_release:Event.TxSignatures.signature)
  
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxSignatures::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    
  } else {
    
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:Event.TxSignatures.signature)
}

// -------------------------------------------------------------------

// EventSignature

// optional string publicKey = 1;
inline void EventSignature::clear_publickey() {
  publickey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EventSignature::publickey() const {
  // @@protoc_insertion_point(field_get:Event.EventSignature.publicKey)
  return publickey_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EventSignature::set_publickey(const ::std::string& value) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.EventSignature.publicKey)
}
inline void EventSignature::set_publickey(const char* value) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.EventSignature.publicKey)
}
inline void EventSignature::set_publickey(const char* value, size_t size) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.EventSignature.publicKey)
}
inline ::std::string* EventSignature::mutable_publickey() {
  
  // @@protoc_insertion_point(field_mutable:Event.EventSignature.publicKey)
  return publickey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EventSignature::release_publickey() {
  // @@protoc_insertion_point(field_release:Event.EventSignature.publicKey)
  
  return publickey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EventSignature::set_allocated_publickey(::std::string* publickey) {
  if (publickey != NULL) {
    
  } else {
    
  }
  publickey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), publickey);
  // @@protoc_insertion_point(field_set_allocated:Event.EventSignature.publicKey)
}

// optional string signature = 2;
inline void EventSignature::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EventSignature::signature() const {
  // @@protoc_insertion_point(field_get:Event.EventSignature.signature)
  return signature_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EventSignature::set_signature(const ::std::string& value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.EventSignature.signature)
}
inline void EventSignature::set_signature(const char* value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.EventSignature.signature)
}
inline void EventSignature::set_signature(const char* value, size_t size) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.EventSignature.signature)
}
inline ::std::string* EventSignature::mutable_signature() {
  
  // @@protoc_insertion_point(field_mutable:Event.EventSignature.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EventSignature::release_signature() {
  // @@protoc_insertion_point(field_release:Event.EventSignature.signature)
  
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EventSignature::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    
  } else {
    
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:Event.EventSignature.signature)
}

// -------------------------------------------------------------------

// Transaction

// repeated .Event.TxSignatures txSignatures = 1;
inline int Transaction::txsignatures_size() const {
  return txsignatures_.size();
}
inline void Transaction::clear_txsignatures() {
  txsignatures_.Clear();
}
inline const ::Event::TxSignatures& Transaction::txsignatures(int index) const {
  // @@protoc_insertion_point(field_get:Event.Transaction.txSignatures)
  return txsignatures_.Get(index);
}
inline ::Event::TxSignatures* Transaction::mutable_txsignatures(int index) {
  // @@protoc_insertion_point(field_mutable:Event.Transaction.txSignatures)
  return txsignatures_.Mutable(index);
}
inline ::Event::TxSignatures* Transaction::add_txsignatures() {
  // @@protoc_insertion_point(field_add:Event.Transaction.txSignatures)
  return txsignatures_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Event::TxSignatures >*
Transaction::mutable_txsignatures() {
  // @@protoc_insertion_point(field_mutable_list:Event.Transaction.txSignatures)
  return &txsignatures_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Event::TxSignatures >&
Transaction::txsignatures() const {
  // @@protoc_insertion_point(field_list:Event.Transaction.txSignatures)
  return txsignatures_;
}

// optional string type = 2;
inline void Transaction::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::type() const {
  // @@protoc_insertion_point(field_get:Event.Transaction.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.Transaction.type)
}
inline void Transaction::set_type(const char* value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.Transaction.type)
}
inline void Transaction::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.Transaction.type)
}
inline ::std::string* Transaction::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:Event.Transaction.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_type() {
  // @@protoc_insertion_point(field_release:Event.Transaction.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:Event.Transaction.type)
}

// optional string senderPubkey = 3;
inline void Transaction::clear_senderpubkey() {
  senderpubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::senderpubkey() const {
  // @@protoc_insertion_point(field_get:Event.Transaction.senderPubkey)
  return senderpubkey_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_senderpubkey(const ::std::string& value) {
  
  senderpubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.Transaction.senderPubkey)
}
inline void Transaction::set_senderpubkey(const char* value) {
  
  senderpubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.Transaction.senderPubkey)
}
inline void Transaction::set_senderpubkey(const char* value, size_t size) {
  
  senderpubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.Transaction.senderPubkey)
}
inline ::std::string* Transaction::mutable_senderpubkey() {
  
  // @@protoc_insertion_point(field_mutable:Event.Transaction.senderPubkey)
  return senderpubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_senderpubkey() {
  // @@protoc_insertion_point(field_release:Event.Transaction.senderPubkey)
  
  return senderpubkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_senderpubkey(::std::string* senderpubkey) {
  if (senderpubkey != NULL) {
    
  } else {
    
  }
  senderpubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), senderpubkey);
  // @@protoc_insertion_point(field_set_allocated:Event.Transaction.senderPubkey)
}

// optional string hash = 4;
inline void Transaction::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::hash() const {
  // @@protoc_insertion_point(field_get:Event.Transaction.hash)
  return hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.Transaction.hash)
}
inline void Transaction::set_hash(const char* value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.Transaction.hash)
}
inline void Transaction::set_hash(const char* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.Transaction.hash)
}
inline ::std::string* Transaction::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:Event.Transaction.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_hash() {
  // @@protoc_insertion_point(field_release:Event.Transaction.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:Event.Transaction.hash)
}

// optional uint64 timestamp = 5;
inline void Transaction::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Transaction::timestamp() const {
  // @@protoc_insertion_point(field_get:Event.Transaction.timestamp)
  return timestamp_;
}
inline void Transaction::set_timestamp(::google::protobuf::uint64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:Event.Transaction.timestamp)
}

// optional .Event.Asset asset = 6;
inline bool Transaction::has_asset() const {
  return !_is_default_instance_ && asset_ != NULL;
}
inline void Transaction::clear_asset() {
  if (GetArenaNoVirtual() == NULL && asset_ != NULL) delete asset_;
  asset_ = NULL;
}
inline const ::Event::Asset& Transaction::asset() const {
  // @@protoc_insertion_point(field_get:Event.Transaction.asset)
  return asset_ != NULL ? *asset_ : *default_instance_->asset_;
}
inline ::Event::Asset* Transaction::mutable_asset() {
  
  if (asset_ == NULL) {
    asset_ = new ::Event::Asset;
  }
  // @@protoc_insertion_point(field_mutable:Event.Transaction.asset)
  return asset_;
}
inline ::Event::Asset* Transaction::release_asset() {
  // @@protoc_insertion_point(field_release:Event.Transaction.asset)
  
  ::Event::Asset* temp = asset_;
  asset_ = NULL;
  return temp;
}
inline void Transaction::set_allocated_asset(::Event::Asset* asset) {
  delete asset_;
  asset_ = asset;
  if (asset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Event.Transaction.asset)
}

// optional .Event.SimpleAsset simpleAsset = 7;
inline bool Transaction::has_simpleasset() const {
  return !_is_default_instance_ && simpleasset_ != NULL;
}
inline void Transaction::clear_simpleasset() {
  if (GetArenaNoVirtual() == NULL && simpleasset_ != NULL) delete simpleasset_;
  simpleasset_ = NULL;
}
inline const ::Event::SimpleAsset& Transaction::simpleasset() const {
  // @@protoc_insertion_point(field_get:Event.Transaction.simpleAsset)
  return simpleasset_ != NULL ? *simpleasset_ : *default_instance_->simpleasset_;
}
inline ::Event::SimpleAsset* Transaction::mutable_simpleasset() {
  
  if (simpleasset_ == NULL) {
    simpleasset_ = new ::Event::SimpleAsset;
  }
  // @@protoc_insertion_point(field_mutable:Event.Transaction.simpleAsset)
  return simpleasset_;
}
inline ::Event::SimpleAsset* Transaction::release_simpleasset() {
  // @@protoc_insertion_point(field_release:Event.Transaction.simpleAsset)
  
  ::Event::SimpleAsset* temp = simpleasset_;
  simpleasset_ = NULL;
  return temp;
}
inline void Transaction::set_allocated_simpleasset(::Event::SimpleAsset* simpleasset) {
  delete simpleasset_;
  simpleasset_ = simpleasset;
  if (simpleasset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Event.Transaction.simpleAsset)
}

// optional .Event.Domain domain = 8;
inline bool Transaction::has_domain() const {
  return !_is_default_instance_ && domain_ != NULL;
}
inline void Transaction::clear_domain() {
  if (GetArenaNoVirtual() == NULL && domain_ != NULL) delete domain_;
  domain_ = NULL;
}
inline const ::Event::Domain& Transaction::domain() const {
  // @@protoc_insertion_point(field_get:Event.Transaction.domain)
  return domain_ != NULL ? *domain_ : *default_instance_->domain_;
}
inline ::Event::Domain* Transaction::mutable_domain() {
  
  if (domain_ == NULL) {
    domain_ = new ::Event::Domain;
  }
  // @@protoc_insertion_point(field_mutable:Event.Transaction.domain)
  return domain_;
}
inline ::Event::Domain* Transaction::release_domain() {
  // @@protoc_insertion_point(field_release:Event.Transaction.domain)
  
  ::Event::Domain* temp = domain_;
  domain_ = NULL;
  return temp;
}
inline void Transaction::set_allocated_domain(::Event::Domain* domain) {
  delete domain_;
  domain_ = domain;
  if (domain) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Event.Transaction.domain)
}

// optional .Event.Account account = 9;
inline bool Transaction::has_account() const {
  return !_is_default_instance_ && account_ != NULL;
}
inline void Transaction::clear_account() {
  if (GetArenaNoVirtual() == NULL && account_ != NULL) delete account_;
  account_ = NULL;
}
inline const ::Event::Account& Transaction::account() const {
  // @@protoc_insertion_point(field_get:Event.Transaction.account)
  return account_ != NULL ? *account_ : *default_instance_->account_;
}
inline ::Event::Account* Transaction::mutable_account() {
  
  if (account_ == NULL) {
    account_ = new ::Event::Account;
  }
  // @@protoc_insertion_point(field_mutable:Event.Transaction.account)
  return account_;
}
inline ::Event::Account* Transaction::release_account() {
  // @@protoc_insertion_point(field_release:Event.Transaction.account)
  
  ::Event::Account* temp = account_;
  account_ = NULL;
  return temp;
}
inline void Transaction::set_allocated_account(::Event::Account* account) {
  delete account_;
  account_ = account;
  if (account) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Event.Transaction.account)
}

// optional .Event.Peer peer = 10;
inline bool Transaction::has_peer() const {
  return !_is_default_instance_ && peer_ != NULL;
}
inline void Transaction::clear_peer() {
  if (GetArenaNoVirtual() == NULL && peer_ != NULL) delete peer_;
  peer_ = NULL;
}
inline const ::Event::Peer& Transaction::peer() const {
  // @@protoc_insertion_point(field_get:Event.Transaction.peer)
  return peer_ != NULL ? *peer_ : *default_instance_->peer_;
}
inline ::Event::Peer* Transaction::mutable_peer() {
  
  if (peer_ == NULL) {
    peer_ = new ::Event::Peer;
  }
  // @@protoc_insertion_point(field_mutable:Event.Transaction.peer)
  return peer_;
}
inline ::Event::Peer* Transaction::release_peer() {
  // @@protoc_insertion_point(field_release:Event.Transaction.peer)
  
  ::Event::Peer* temp = peer_;
  peer_ = NULL;
  return temp;
}
inline void Transaction::set_allocated_peer(::Event::Peer* peer) {
  delete peer_;
  peer_ = peer;
  if (peer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Event.Transaction.peer)
}

// optional string receivePubkey = 11;
inline void Transaction::clear_receivepubkey() {
  receivepubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::receivepubkey() const {
  // @@protoc_insertion_point(field_get:Event.Transaction.receivePubkey)
  return receivepubkey_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_receivepubkey(const ::std::string& value) {
  
  receivepubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.Transaction.receivePubkey)
}
inline void Transaction::set_receivepubkey(const char* value) {
  
  receivepubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.Transaction.receivePubkey)
}
inline void Transaction::set_receivepubkey(const char* value, size_t size) {
  
  receivepubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.Transaction.receivePubkey)
}
inline ::std::string* Transaction::mutable_receivepubkey() {
  
  // @@protoc_insertion_point(field_mutable:Event.Transaction.receivePubkey)
  return receivepubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_receivepubkey() {
  // @@protoc_insertion_point(field_release:Event.Transaction.receivePubkey)
  
  return receivepubkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_receivepubkey(::std::string* receivepubkey) {
  if (receivepubkey != NULL) {
    
  } else {
    
  }
  receivepubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), receivepubkey);
  // @@protoc_insertion_point(field_set_allocated:Event.Transaction.receivePubkey)
}

// -------------------------------------------------------------------

// ConsensusEvent

// repeated .Event.EventSignature eventSignatures = 1;
inline int ConsensusEvent::eventsignatures_size() const {
  return eventsignatures_.size();
}
inline void ConsensusEvent::clear_eventsignatures() {
  eventsignatures_.Clear();
}
inline const ::Event::EventSignature& ConsensusEvent::eventsignatures(int index) const {
  // @@protoc_insertion_point(field_get:Event.ConsensusEvent.eventSignatures)
  return eventsignatures_.Get(index);
}
inline ::Event::EventSignature* ConsensusEvent::mutable_eventsignatures(int index) {
  // @@protoc_insertion_point(field_mutable:Event.ConsensusEvent.eventSignatures)
  return eventsignatures_.Mutable(index);
}
inline ::Event::EventSignature* ConsensusEvent::add_eventsignatures() {
  // @@protoc_insertion_point(field_add:Event.ConsensusEvent.eventSignatures)
  return eventsignatures_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Event::EventSignature >*
ConsensusEvent::mutable_eventsignatures() {
  // @@protoc_insertion_point(field_mutable_list:Event.ConsensusEvent.eventSignatures)
  return &eventsignatures_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Event::EventSignature >&
ConsensusEvent::eventsignatures() const {
  // @@protoc_insertion_point(field_list:Event.ConsensusEvent.eventSignatures)
  return eventsignatures_;
}

// optional .Event.Transaction transaction = 2;
inline bool ConsensusEvent::has_transaction() const {
  return !_is_default_instance_ && transaction_ != NULL;
}
inline void ConsensusEvent::clear_transaction() {
  if (GetArenaNoVirtual() == NULL && transaction_ != NULL) delete transaction_;
  transaction_ = NULL;
}
inline const ::Event::Transaction& ConsensusEvent::transaction() const {
  // @@protoc_insertion_point(field_get:Event.ConsensusEvent.transaction)
  return transaction_ != NULL ? *transaction_ : *default_instance_->transaction_;
}
inline ::Event::Transaction* ConsensusEvent::mutable_transaction() {
  
  if (transaction_ == NULL) {
    transaction_ = new ::Event::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:Event.ConsensusEvent.transaction)
  return transaction_;
}
inline ::Event::Transaction* ConsensusEvent::release_transaction() {
  // @@protoc_insertion_point(field_release:Event.ConsensusEvent.transaction)
  
  ::Event::Transaction* temp = transaction_;
  transaction_ = NULL;
  return temp;
}
inline void ConsensusEvent::set_allocated_transaction(::Event::Transaction* transaction) {
  delete transaction_;
  transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Event.ConsensusEvent.transaction)
}

// optional uint64 order = 3;
inline void ConsensusEvent::clear_order() {
  order_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ConsensusEvent::order() const {
  // @@protoc_insertion_point(field_get:Event.ConsensusEvent.order)
  return order_;
}
inline void ConsensusEvent::set_order(::google::protobuf::uint64 value) {
  
  order_ = value;
  // @@protoc_insertion_point(field_set:Event.ConsensusEvent.order)
}

// -------------------------------------------------------------------

// StatusResponse

// optional string value = 1;
inline void StatusResponse::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StatusResponse::value() const {
  // @@protoc_insertion_point(field_get:Event.StatusResponse.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StatusResponse::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.StatusResponse.value)
}
inline void StatusResponse::set_value(const char* value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.StatusResponse.value)
}
inline void StatusResponse::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.StatusResponse.value)
}
inline ::std::string* StatusResponse::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:Event.StatusResponse.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StatusResponse::release_value() {
  // @@protoc_insertion_point(field_release:Event.StatusResponse.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StatusResponse::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:Event.StatusResponse.value)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Event

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_event_2eproto__INCLUDED
